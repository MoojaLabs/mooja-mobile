# Flutter MVP Development Rules
# For 10-15 screen apps with 1-3 dev teams focused on scalability and maintainability

## Core Development Principles
- Prioritize code readability and maintainability over clever solutions
- Write code as if the person maintaining it is a violent psychopath who knows where you live
- Every feature should be implemented with future scaling in mind, but don't over-engineer for problems you don't have yet
- Favor composition over inheritance, explicit over implicit
- If you're copy-pasting code more than twice, extract it into a reusable component

## Project Structure & Organization
- Follow feature-first architecture: organize by features, not by technical layers
- Structure: `lib/features/[feature_name]/presentation/pages|widgets|blocs/`
- Keep shared/global code in `lib/core/` (themes, widgets, utils, constants)
- Maximum 3 levels of folder nesting - if deeper, refactor into separate features
- File names: use snake_case, be descriptive (user_profile_page.dart, not profile.dart)
- One public class per file, private classes can be in the same file if tightly coupled

## Flutter & Dart Best Practices

### Widget Construction
- ALWAYS use const constructors when possible
- Extract complex widgets into separate classes if build method > 50 lines
- Use named parameters for widget constructors with 3+ parameters
- Prefer StatelessWidget over StatefulWidget unless state is absolutely necessary
- Use composition over large widget trees - break down into smaller, focused widgets

```dart
// ✅ Good
class UserCard extends StatelessWidget {
  const UserCard({
    super.key,
    required this.user,
    this.onTap,
  });
  
  final User user;
  final VoidCallback? onTap;
  
  @override
  Widget build(BuildContext context) => Card(
    child: ListTile(
      title: Text(user.name),
      onTap: onTap,
    ),
  );
}

// ❌ Avoid
Widget buildUserCard(User user) {
  return Card(child: ListTile(title: Text(user.name)));
}
```

### State Management with BLoC
- Each feature should have its own BLoC/Cubit - don't share BLoCs across unrelated features
- Use Cubit for simple state management, BLoC for complex business logic with events
- Always implement proper state classes with copyWith methods and equality
- Never put business logic in widgets - it belongs in BLoCs/Cubits
- Use sealed classes/enums for state management when possible
- Always dispose BLoCs properly and handle loading/error states in UI

```dart
// ✅ Good BLoC structure
@freezed
class UserState with _$UserState {
  const factory UserState.initial() = _Initial;
  const factory UserState.loading() = _Loading;
  const factory UserState.loaded(List<User> users) = _Loaded;
  const factory UserState.error(String message) = _Error;
}

class UserCubit extends Cubit<UserState> {
  UserCubit(this._repository) : super(const UserState.initial());
  
  final UserRepository _repository;
  
  Future<void> loadUsers() async {
    emit(const UserState.loading());
    try {
      final users = await _repository.getUsers();
      emit(UserState.loaded(users));
    } catch (e) {
      emit(UserState.error(e.toString()));
    }
  }
}
```

### Navigation with GoRouter
- Define all routes in a centralized router configuration
- Use typed route parameters, avoid string-based navigation when possible
- Implement proper error handling and fallback routes
- Use ShellRoute for persistent navigation elements (bottom nav, drawer)
- Keep route definitions close to their corresponding pages for maintainability

```dart
// ✅ Good route structure
final router = GoRouter(
  routes: [
    ShellRoute(
      builder: (context, state, child) => MainLayout(child: child),
      routes: [
        GoRoute(
          path: '/home',
          builder: (context, state) => const HomePage(),
        ),
        GoRoute(
          path: '/profile/:userId',
          builder: (context, state) {
            final userId = state.pathParameters['userId']!;
            return ProfilePage(userId: userId);
          },
        ),
      ],
    ),
  ],
);
```

### Performance Guidelines
- Use ListView.builder for lists > 20 items
- Implement proper image caching with CachedNetworkImage
- Use RepaintBoundary for complex animations
- Avoid rebuilding expensive widgets - use keys and const constructors
- Profile your app regularly with Flutter DevTools
- Lazy load heavy resources and implement pagination for large datasets

### Error Handling
- Always handle async operations with try-catch blocks
- Check widget.mounted before calling setState after async operations
- Implement global error handling with proper user feedback
- Use Result/Either types for operation outcomes instead of throwing exceptions everywhere
- Log errors appropriately but don't spam the console

```dart
// ✅ Good error handling
Future<void> loadData() async {
  try {
    emit(const DataState.loading());
    final data = await _repository.fetchData();
    if (!isClosed) emit(DataState.loaded(data));
  } catch (e, stackTrace) {
    _logger.error('Failed to load data', e, stackTrace);
    if (!isClosed) emit(DataState.error('Failed to load data. Please try again.'));
  }
}
```

### Code Style & Formatting
- Follow official Dart style guide religiously
- Use meaningful variable and function names - no abbreviations unless universally understood
- Keep functions under 30 lines, classes under 300 lines
- Add dartdocs for public APIs, especially complex business logic
- Use trailing commas for better git diffs
- Group imports: dart imports, flutter imports, external packages, internal imports

### Testing Strategy (MVP-appropriate)
- Write unit tests for business logic (BLoCs/Cubits and services)
- Write widget tests for complex custom widgets
- Don't obsess over 100% coverage - focus on critical paths and complex logic
- Mock external dependencies properly
- Integration tests for main user flows only - don't test every screen

### Dependency Management
- Keep pubspec.yaml organized with comments for package purposes
- Pin major versions to avoid breaking changes
- Regularly update dependencies but test thoroughly
- Use dependency injection with get_it for services, not for every small class

### Documentation & Comments
- README.md should explain how to run the project and key architectural decisions
- Comment complex business logic, not obvious code
- Use TODO comments with dates and names for technical debt
- Document API integrations and external service configurations

## MVP-Specific Guidelines

### Feature Development Priority
1. Core user journey functionality first
2. Error states and edge cases second  
3. Nice-to-have features last
4. Performance optimization throughout, not as an afterthought

### Technical Debt Management
- Address technical debt immediately if it affects user experience
- Schedule refactoring sprints every 4-6 weeks
- Keep a technical debt backlog and prioritize by impact
- Don't let "temporary" solutions become permanent

### Code Review Guidelines
- Every PR should be reviewed by at least one other team member
- Focus on architecture, readability, and maintainability over micro-optimizations
- Check for proper error handling and user experience impact
- Ensure new code follows established patterns in the codebase

### Scalability Considerations
- Design data models with growth in mind (but don't over-engineer)
- Use proper separation of concerns from the start
- Keep API integration logic separate from UI logic
- Plan for feature flags and A/B testing capabilities
- Consider offline capabilities for critical features

## Anti-Patterns to Avoid

### BLoC/Cubit Anti-patterns
- Don't put UI logic in BLoCs (formatting, colors, etc.)
- Don't create god BLoCs that handle multiple unrelated features
- Don't forget to dispose BLoCs and close streams
- Don't emit new states from within state classes

### Widget Anti-patterns
- Don't build widgets in functions, use proper Widget classes
- Don't pass BuildContext across async gaps without checking mounted
- Don't create new widgets inside build methods repeatedly
- Don't ignore the widget key system for lists and animated content

### Architecture Anti-patterns
- Don't tightly couple features - they should be independently testable
- Don't put business logic in widgets or main function
- Don't hardcode strings, colors, or dimensions throughout the app
- Don't ignore proper error boundaries and fallback UIs

### Performance Anti-patterns
- Don't load all data upfront - implement proper lazy loading
- Don't ignore memory leaks from unclosed streams or undisposed controllers
- Don't use heavy operations in build methods
- Don't ignore the importance of const constructors

## AI Assistant Guidance
When suggesting code improvements or new implementations:
1. Always provide the reasoning behind architectural decisions
2. Show both the pattern to follow AND what to avoid
3. Consider the team size and MVP constraints when suggesting solutions
4. Prioritize maintainability and readability over clever code
5. Suggest incremental improvements rather than major rewrites
6. Always consider the user experience impact of technical decisions
7. Provide practical, copy-pasteable examples that fit the existing codebase patterns
8. Point out potential future scaling issues but don't over-engineer for them now
9. Suggest testing strategies appropriate for MVP timeline constraints
10. Help maintain consistency with existing code patterns and architecture decisions

## Quick Checklist for New Features
- [ ] Feature has proper error handling and loading states
- [ ] BLoC/Cubit follows established patterns in the codebase  
- [ ] Widget is properly composed and uses const where possible
- [ ] Navigation integration follows GoRouter patterns
- [ ] User experience is smooth with proper feedback
- [ ] Code is readable and follows project conventions
- [ ] No obvious performance red flags
- [ ] Basic tests for critical logic paths
- [ ] Proper disposal of resources
- [ ] Consistent with existing UI patterns and theme usage